/* auto-generated by NAPI-RS */
/* eslint-disable */
/** Convert a Base64 string to a buffer. */
export declare function base64ToBuffer(base64: string): Array<number>

/** Convert a buffer to Base64 string. */
export declare function bufferToBase64(buffer: Uint8Array): string

/**
 * Extract text content from a PDF document.
 *
 * This replaces pdf-parse (JS) with a native Rust implementation using pdf-extract.
 * Returns the extracted text as a single string, with pages separated by newlines.
 */
export declare function extractTextFromPdf(bytes: Uint8Array): string

/**
 * Optimize an image: resize and/or compress.
 *
 * Options:
 * - `max_width`: Maximum width in pixels (0 = no limit)
 * - `max_height`: Maximum height in pixels (0 = no limit)
 * - `quality`: JPEG quality (1-100, only used if format is JPEG)
 * - `format`: Output format ("jpeg", "png", "webp", or "auto" to keep original)
 */
export interface ImageOptimizeOptions {
  maxWidth?: number
  maxHeight?: number
  quality?: number
  format?: string
}

/**
 * Convert any supported image format (PNG, JPEG, â€¦) to WebP.
 *
 * This mirrors the behavior of the Transformer example on the NAPI-RS homepage:
 * it decodes the image from memory and re-encodes it as WebP in memory.
 *
 * **Input:** Buffer (Uint8Array) - Binary image data in memory
 */
export declare function imageToWebp(bytes: Uint8Array): Array<number>

/**
 * Convert a Base64-encoded image to WebP format.
 *
 * **Input:** Base64 string (String) - Base64-encoded image data
 */
export declare function imageToWebpFromBase64(base64: string): Array<number>

/**
 * Convert an image file to WebP format.
 *
 * **Input:** File path (String) - Path to the image file on disk
 */
export declare function imageToWebpFromFile(path: string): Array<number>

/**
 * Normalize a CV file to PDF and optionally compress it.
 *
 * V1 behavior:
 * - If the mime type is a supported image (`image/png`, `image/jpeg`, `image/jpg`),
 *   the image is decoded, optionally downscaled, recompressed as JPEG,
 *   and wrapped into a single-page PDF.
 * - If the mime type is `application/pdf`, the input is currently validated
 *   (must start with `%PDF-`) then returned unchanged. This is the hook where
 *   a real PDF optimization pipeline can be implemented later.
 * - For any other mime type, the input bytes are returned unchanged.
 */
export declare function normalizeCvToPdf(bytes: Uint8Array, mime: string): Array<number>

/**
 * Optimize an image from a buffer.
 *
 * **Input:** Buffer (Uint8Array) - Binary image data in memory
 */
export declare function optimizeImage(bytes: Uint8Array, options?: ImageOptimizeOptions | undefined | null): Array<number>

/**
 * Optimize an image from a Base64-encoded string.
 *
 * **Input:** Base64 string (String) - Base64-encoded image data
 */
export declare function optimizeImageFromBase64(base64: string, options?: ImageOptimizeOptions | undefined | null): Array<number>

/**
 * Optimize an image from a file path.
 *
 * **Input:** File path (String) - Path to the image file on disk
 */
export declare function optimizeImageFromFile(path: string, options?: ImageOptimizeOptions | undefined | null): Array<number>
